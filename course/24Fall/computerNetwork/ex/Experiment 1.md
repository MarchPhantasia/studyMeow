好的，我们将直接聚焦于实验内容及代码实现过程。以下是调整后的实验过程大纲，专注于实现步骤和代码中的具体技术实现。

### 实验内容与代码实现大纲

1. **Socket编程及基本HTTP代理服务器实现**
    - **Socket编程步骤**
        1. **创建服务器端Socket**
            - 使用`socket()`函数创建服务器端的Socket。指定地址族为IPv4(`AF_INET`)，使用流套接字(`SOCK_STREAM`)。
            - 调用`bind()`将Socket与本地IP地址和端口（如8080）绑定。
            - 使用`listen()`函数监听客户端连接请求。
        2. **接受客户端连接**
            - 当有客户端请求时，使用`accept()`函数接受连接，创建一个新的Socket与客户端进行通信。
            - 多线程处理每个客户端请求，通过`_beginthreadex()`创建线程，为每个客户端请求分配一个代理线程。

    - **HTTP请求与响应处理**
        1. **解析客户端HTTP请求**
            - 代理服务器接收到客户端的HTTP请求后，使用`recv()`函数读取请求数据到缓冲区。
            - 解析请求报文，提取出关键的HTTP头信息，如请求方法（GET/POST）、URL、Host等。代码中使用`ParseHttpHead()`函数完成这一解析。
        2. **连接目标服务器并转发请求**
            - 根据解析出的URL，通过`gethostbyname()`函数解析域名为IP地址（如果是高版本Windows，使用`getaddrinfo()`进行IP解析）。
            - 创建与目标服务器的连接，使用`connect()`函数建立TCP连接。
            - 将客户端的请求通过`send()`函数发送给目标服务器。

    - **接收并转发目标服务器的响应**
        1. **接收响应**
            - 代理服务器通过`recv()`函数从目标服务器接收响应报文，并将其存储到缓冲区。
        2. **转发响应**
            - 将目标服务器返回的HTTP响应报文通过`send()`函数发送回客户端，完成一次完整的代理请求-响应流程。

2. **支持缓存功能的HTTP代理服务器实现**
    - **缓存机制设计**
        1. **判断是否有缓存**
            - 在接收到客户端请求后，代理服务器首先判断该请求的URL是否已有缓存。使用URL作为文件名，在本地文件系统中查找相应的缓存文件。
            - 如果缓存存在，则构造带有`If-Modified-Since`头的请求，向目标服务器确认缓存的有效性。
        2. **缓存命中处理**
            - 如果目标服务器返回304（未修改）状态码，代理服务器直接从缓存文件中读取数据，发送给客户端。
        3. **缓存更新**
            - 如果目标服务器返回200状态码（内容已修改），代理服务器将更新缓存，将新的响应数据写入缓存文件，同时将响应返回给客户端。

    - **缓存实现步骤**
        1. **缓存文件创建与读取**
            - 当接收到原服务器返回的响应报文时，代理服务器将其内容存储到一个以URL命名的本地文件中。
            - 通过`makeFilename()`函数根据URL生成唯一的缓存文件名，缓存内容为目标服务器的完整HTTP响应。
        2. **缓存验证**
            - 代理服务器在处理客户端请求时，通过`if-modified-since`头部来验证缓存内容的有效性。如果内容未被修改，则直接返回缓存内容，减少对目标服务器的访问。

3. **网站/用户过滤功能实现**
    - **网站过滤功能**
        - 代理服务器在解析HTTP请求后，通过比对请求的URL与预设的禁止访问的网站列表，决定是否允许该请求继续。
        - 在`ForbiddenToConnect()`函数中检查URL是否在禁止访问列表中，如果匹配则返回错误信息，拒绝访问。

    - **用户过滤功能**
        - 通过比对客户端的IP地址，代理服务器可以限制特定用户访问外网。例如，通过比对请求的客户端IP与禁用IP列表，拒绝来自特定IP的连接请求。
        - 在`UserIsForbidden()`函数中判断客户端IP是否在禁止列表中，如果匹配则拒绝访问。

4. **钓鱼网站功能实现**
    - **重定向钓鱼**
        1. **URL检查**
            - 在处理客户端的请求时，代理服务器检查请求的URL是否属于需要进行钓鱼重定向的网站。例如，当URL匹配`jwc.hit.edu.cn`时，代理服务器会将请求重定向到`jwts.hit.edu.cn`。
        2. **构造重定向报文**
            - 使用302重定向状态码构造HTTP响应报文，并在其中加入`Location`头，将客户端重定向到指定的钓鱼网站。代理服务器通过`send()`函数将这个响应报文返回给客户端。

5. **多线程处理机制**
    - **多线程实现**
        - 每个客户端请求都会由代理服务器创建一个新的线程进行处理，避免阻塞主线程的继续工作。代理服务器使用`_beginthreadex()`函数创建新线程，并传递必要的参数。
        - 每个线程独立处理一个客户端的请求，包括解析请求、转发到目标服务器、接收响应和发送给客户端。
        - 在线程结束时，使用`_endthreadex()`释放线程资源。

6. **关键代码片段展示**
    1. **Socket初始化与连接**
        ```cpp
        // 初始化服务器Socket
        BOOL InitSocket() {
            ProxyServer = socket(AF_INET, SOCK_STREAM, 0);
            bind(ProxyServer, (SOCKADDR*)&ProxyServerAddr, sizeof(SOCKADDR));
            listen(ProxyServer, SOMAXCONN);
            return TRUE;
        }
        ```
    2. **HTTP请求解析**
        ```cpp
        void ParseHttpHead(char *buffer, HttpHeader *httpHeader) {
            // 解析HTTP请求头，提取URL、Host等信息
            if (p[0] == 'G') {
                memcpy(httpHeader->method, "GET", 3);
                // 提取URL
            }
        }
        ```
    3. **缓存处理**
        ```cpp
        if (haveCache) {
            // 读取缓存文件
            FILE *cacheFile = fopen(filename, "r");
            fread(cacheBuffer, sizeof(char), MAXSIZE, cacheFile);
            fclose(cacheFile);
            send(clientSocket, cacheBuffer, sizeof(cacheBuffer), 0);
        }
        ```

### 总结：
本实验实现了一个多功能的HTTP代理服务器，支持多线程、缓存、网站和用户过滤、钓鱼重定向等功能。代理服务器通过Socket编程与HTTP协议解析，与客户端和目标服务器进行交互，并通过文件系统实现了缓存功能。


# 实验一我自认为写的还行，能用
