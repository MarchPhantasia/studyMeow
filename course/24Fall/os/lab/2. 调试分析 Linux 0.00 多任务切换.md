> [!HINT] 文章已设置目录。

## 2.1. 实验目的

- 通过调试一个简单的多任务内核实例，使大家可以熟练的掌握调试系统内核的方法；
- 掌握 Bochs 虚拟机的调试技巧；
- 通过调试和记录，理解操作系统及应用程序在内存中是如何进行分配与管理的；

## 2.2. 实验内容

通过调试一个简单的多任务内核实例，使大家可以熟练的掌握调试系统内核的方法。这个内核示例中包含两个特权级 `3` 的用户任务和一个系统调用中断过程。我们首先说明这个简单内核的基本结构和加载运行的基本原理，然后描述它是如何被加载进机器 `RAM` 内存中以及两个任务是如何进行切换运行的。

### 2.2.1. 掌握 Bochs 虚拟机的调试技巧

> [!EXAMPLE] 已经在实验一完成

- 如何单步跟踪？
- 如何设置断点进行调试？
- 如何查看通用寄存器的值？
- 如何查看系统寄存器的值？
- 如何查看内存指定位置的值？
- 如何查看各种表，如 `gdt` ，`idt` ，`ldt` 等？
- 如何查看 `TSS`？
- 如何查看栈中的内容？
- 如何在内存指定地方进行反汇编？

## 2.3. 实验报告

通过仔细的调试与跟踪程序，完成以下任务：

1. 当执行完 `system_interrupt` 函数，执行 `153` 行 `iret` 时，记录栈的变化情况。
2. 当进入和退出 `system_interrupt` 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？
3. 当时钟中断发生，进入到 `timer_interrupt` 程序，请详细记录从任务 `0` 切换到任务 `1` 的过程。
4. 又过了 `10ms` ，从任务 1 切换回到任务 `0` ，整个流程是怎样的？ `TSS` 是如何变化的？各个寄存器的值是如何变化的？
5. 请详细总结任务切换的过程。

### 2.3.1 当执行完 `system_interrupt` 函数，执行 `153` 行 `iret` 时，记录栈的变化情况

#### 2.3.1.1 iret 介绍

使用 `bx166` 在 `system_interrupt` 函数入口处设置断点，然后继续执行函数。`system_interrupt` 的代码实现如下：

``` asm
system_interrupt:
	push %ds # 保存寄存器上下文
	pushl %edx
	pushl %ecx
	pushl %ebx
	pushl %eax
	movl $0x10, %edx # 切换到内核数据段
	mov %dx, %ds
	call write_char # 调用函数在屏幕上显示字符
	popl %eax # 恢复寄存器上下文
	popl %ebx
	popl %ecx
	popl %edx
	pop %ds
	iret
```

首先介绍一下 `system_interrupt` 函数的执行机制：

1. 保存寄存器上下文
2. 执行 `writer_char` 调用，在屏幕上显示字符
3. 恢复寄存器上下文
4. 调用 `iret` 中断返回

再介绍一下 `iret` 操作的执行机制。简单来说，`iret` 操作执行中断返回指令，**从而切换到特权级 3 的任务 0 或 1 中执行**。

具体而言 `IRET(interrupt return)` 中断返回，中断服务程序的最后一条指令。`IRET` 指令将推入堆栈的段地址和偏移地址弹出，使程序返回到原来发生中断的地方。其作用是从中断中恢复中断前的状态，具体过程如下：

1. 从堆栈中**弹出 `EIP` 寄存器的值**，以恢复中断或异常处理程序返回到的下一条指令的地址。
2. 从堆栈中**弹出 `CS` 寄存器的值**，以恢复中断或异常处理程序返回到的代码段。
3. 从堆栈中**弹出标志寄存器 `EFLAGS` 的值**,即恢复中断前的标志寄存器的状态。
4. 如果在中断或异常处理程序执行期间切换了堆栈，`iret` 会从堆栈中**弹出新的 `ESP` 寄存器的值（堆栈指针）**，以恢复原始堆栈，允许在**不同特权级别（如内核态和用户态）之间切换**
5. 根据从堆栈中弹出的 **`SS` 寄存器的值**，恢复到原有的堆栈段选择子，这允许在**不同特权级别（如内核态和用户态）之间切换**。

#### 2.3.1.2 调试过程与堆栈的变化记录

**执行 `b 0x17c` 在执行 `iret` 操作之前进行中断。** 并且查看当前的栈的情况。

- 可以看见在执行 `iret` 命令前，当前环境的 `eip` 寄存器的值为 `0x17c`，`cs` 寄存器的值为 `0x8`，`eflags` 寄存器的值为 `0x283`，`esp` 寄存器的值为 `0xe4c`，`ss` 寄存器的值为 `0x10`.
![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241122110751.png)
- 详细查看当前栈中的情况，
	- 栈顶的 `0x10eb` 应当在执行 `iret` 操作后，被赋值给 `eip` 寄存器。
	- `0xf` 应当被赋值给 `cs` 寄存器。
	- `0x246` 应当被赋值给 `eflags` 寄存器。
	- `0xbd8` 应当被赋值给 `esp` 寄存器。
	- `0x17` 应当被赋值给 `ss` 寄存器
![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241122113118.png)

**单步步进后，执行 `iret` 操作后查看当前的寄存器情况和栈的状况。**
可以看见当前的 `esp`、`eip`、`eflags`、`cs` 和 `ss` 寄存器都按照我们说的过程被正确的赋值了。**此时的栈中是当前任务的用户态堆栈** ，**但是 `ds` 寄存器的内容没有发生变化。**
![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241122113610.png)

### 2.3.2 当进入和退出 `system_interrupt` 时，都发生了模式切换，请总结模式切换时，特权级是如何改变的？栈切换吗？如何进行切换的？

- **特权级切换**：当进入 `system_interrupt` 的时候，CPU 的特权级由 `3` 更改为 `0`，从**用户模式进入了内核模式**，而退出的时候，CPI 的特权级从 `0` 更改回 `3`，从**内核模式切换回用户模式**。
- **栈切换**：进入和退出 system_interrupt 时，**都发生了栈切换，前者从当前任务用户栈切换为当前任务内核栈，后者从当前任务内核栈切换为当前任务用户栈**。

#### 2.3.2.1 特权级的切换

首先要明确的是，进入和退出 `system_interrupt` 的时候都发生了**特权级的切换**，*当程序把控制转移到另一个具有不同特权级的代码段中时，处理器就会改变 CPL*。

在对中断门进行初始化的过程当中，我们对中断门进行了**特权级 0**的设置，如下面的代码所示：

``` asm
setup_idt:
	lea ignore_int,%edx
	movl $0x00080000,%eax
	movw %dx,%ax		/* selector = 0x0008 = cs */
	movw $0x8E00,%dx	/*# 中断门类型，特权级为 0。 */
	lea idt,%edi
	mov $256,%ecx
rp_sidt:
	movl %eax,(%edi)
	movl %edx,4(%edi)    # 循环为256个中断门设置特权级为0
	addl $8,%edi
	dec %ecx
	jne rp_sidt
	lidt lidt_opcode
	ret
```

**所以当进行 `int 0x80` 系统中断调用的时候，就会根据当前调用的中断门的选择子对应的中断门描述符中设置的 DPL 自动切换 CPU 的 CPL 为 DPL 中设置的特权级 0**。

与之相对应的是，当调用了 `int 0x80` 系统中断调用的时候，会进行如下操作：

- 将用户态的 `EFLAGS`、`CS` 和 `EIP` 压入内核态堆栈。
- 用户态的 `ESP` 和 `SS` 暂时存放在内核态堆栈中（供 `iret` 使用）。

所以在进行 `iret` 命令中断返回的时候，会从栈里获得 `CS` 和 `SS` 寄存器的内容，`CS` 寄存器和 `SS` 寄存器中都含有 `RPL` 字段，通过 `RPL` 字段和 ` CS ` 寄存器指向的段描述符中的 ` DPL ` 字段的匹配，来确定特权级的切换。下图中在执行 ` iret ` 命令后，可以看见当前的 ` CS ` 寄存器中的内容是 ` 0xf `，那么 ` RPL ` 字段就是 `3`，代表恢复了用户模式。

![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241122113610.png)

#### 2.3.2.2 栈的切换

进入 `system_interrupt` 之前通过命令 `info tss` 可以查看当前的 `tr`、`ss` 寄存器的内容。`tr` 中可以看见当前的 `tss` 为**任务 0 的 tss 段**，根据前文叙述的 `iret` 命令的介绍，会将**用户态的 `ESP` 和 `SS` 暂时存放在内核态堆栈中（供 `iret` 使用）。** 稍后在退出的时候会使用到这两个寄存器进行栈的切换。

![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241122191249.png)

- 当进入 `system_interrupt` 时，**`tr` 寄存器没有发生改变，但是由于中断的执行，对中断门的调用时会切换到内核态，此时会在 `tss` 中寻找内核栈**，然后切换到内核栈。
- 当退出 `system_interrupt` 时，**由于在中断调用过程中存在压入的 `esp` 堆栈指针和 `ss` 堆栈段选择子，会重新赋值给中断返回的寄存器，此时完成了从内核栈到用户栈的切换。**

### 2.3.3 当时钟中断发生，进入到 `timer_interrupt` 程序，请详细记录从任务 `0` 切换到任务 `1` 的过程

> [!ERROR] 使用命令 `b 0x12a` 在 `timer_interrupt` 函数内进行中断时存在 bug，无法正确进行 break，无法停止在对 `%ds` 进行 `push` 的语句。

使用命令 `b 0x12b` 在 `timer_interrupt` 函数内进行中断。查看当前的各个寄存器的状态：

![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241123005643.png)

> 需要注意的是，在执行 `task0` 或者 `task1` 时，绝大部分时间都在 loop 语句中，所以我们认为当执行时间中断时，`task` 正在执行 `loop` 语句。

先对 `timer_interrupt` 函数进行介绍，`timer_interrupt` 的中断门描述符在 `idt` 初始化的时候已经定义过，**`DPL` 为 `0`，是内核级**。所以从 `task0/1` 进行始终中断时，cpu 的 `CPL` 会切换，**从用户态切换到内核态**，并且和 `system_interrupt` 一样，**会进行下面这两部分操作**。

- 将用户态的 `EFLAGS`、`CS` 和 `EIP` 压入内核态堆栈。
- 用户态的 `ESP` 和 `SS` 暂时存放在内核态堆栈中（供 `iret` 使用）。

`system_interrupt` 的代码如下，**我们在代码中进行了详细的注释**，稍后我们进行具体的解析：

``` assembly
/* Timer interrupt handler */
.align 2
timer_interrupt:
	push %ds
	pushl %eax
	movl $0x10, %eax
	mov %ax, %ds
	movb $0x20, %al   # 加载中断控制器的中断结束信号（EOI，End of Interrupt）命令 `0x20` 到 `%al`。
	outb %al, $0x20 # 通过 I/O 端口 `0x20`，将 EOI 命令发送给 8259 中断控制器，通知中断处理结束，可以响应新的中断
	movl $1, %eax
	cmpl %eax, current        #比较当前任务标志变量 `current` 的值与 `1`
	je 1f                                     # 如果相等（表示当前运行的是任务 1），则跳转到标签 `1f`。
	movl %eax, current     # #  更新当前任务标志变量 `current` 为 `1`，表示任务切换到任务 1。
	ljmp $TSS0_SEL, $0   # 执行长跳转到任务 1 的 TSS 段（`TSS1_SEL`）。
	jmp 2f
1:		  movl $0, current    #  更新当前任务标志变量 `current` 为 `0`，表示任务切换到任务 0。
	ljmp $TSS1_SEL, $0  # 执行长跳转到任务 0 的 TSS 段（`TSS0_SEL`）。
2:	  popl %eax
	pop %ds
	iret

```

在进入 `timer_interrupt` 后，首先将 `ds` 和 `eax` 压入栈，保存通用寄存器 `%ds` 和 `%eax` 的值到栈中，保护中断服务程序中的临时计算不会破坏原寄存器值，并让 `ds` 指向内核的数据段，`eax` 寄存器分别完成了**加载命令 `0x20` 通知中断控制器（PIC）完成中断处理**以及**作为变量进行当前任务的判断**两个任务。下图中 `%ds` 指向了当前的内核段：

![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241123024850.png)

**加载命令 `0x20` 通知中断控制器（PIC）完成中断处理**：任务中这部分的执行较为简单，通过加载中断控制器的中断结束信号（EOI，End of Interrupt）命令 `0x20` 到 `%al`，将 EOI 命令发送给 8259 中断控制器，通知中断处理结束，可以响应新的中断。

**作为变量进行当前任务的判断**：通过对当前的 **`current`** 变量与 ` %eax ` 存储的立即数 ` 1 ` 进行比较，` current ` 变量代表着当前执行任务的标签。如果比较当前任务标志变量 `current` 的值与 `1` 为真，**则跳转到标签 `1` (`je 1f`)**，更新当前任务标志变量 `current` 为 `0`，表示任务切换到任务 0，执行长跳转到任务 0 的 TSS 段（`TSS0_SEL`），当执行完任务 0 返回 `task1` 时，会根据原来 `TSS1` 中的 `CS` 和 `EIP` 寄存器继续标签 2 中代码的执行。要注意的是，**长跳转操作触发硬件任务切换**：
- *加载 TSS0 的上下文（包括段寄存器、寄存器、堆栈指针等）。*
- *切换到任务 0 的内核堆栈。*
- *跳转到任务 0 的执行入口*。
如果当前 `current` 为 0（**本章节关于 task0 向 task1 切换的部分**），**不进行跳转，正常执行代码，更新当前任务标志变量 `current` 为 `1`**，表示任务切换到任务 1，执行长跳转到任务 1 的 TSS 段（`TSS1_SEL`），硬件任务的切换就是加载 `TSS1` 的相关内容，具体内容和上述流程类似。**最后执行标签 `2` 中的代码段，对 `ds` 和 `eax` 寄存器的内容进行恢复，并进行中断返回 `iret` 操作，进行任务的切换。**

执行跳转到 `task1` 的长跳转指令后，查看当前的堆栈，可以发现大多数和任务相关的变量都被更新了，`%tr` 寄存器也指向了 `task1` 的 tss 部分，完成了 `task0` 到 `task1` 的切换：

![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241123025705.png)

### 2.3.4 又过了 `10ms` ，从任务 1 切换回到任务 `0` ，整个流程是怎样的？ `TSS` 是如何变化的？各个寄存器的值是如何变化的？

#### 2.3.4.1 切换流程（简介）

对 `task1` 到 `task0` 的切换，大部分过程和 `task0` 到 `task1` 的切换过程很类似，不过多介绍，**对于寄存器状态的保存，`current` 变量的使用等都一致**。*不同之处在于*，代码执行过程中，由于 `current` 变量是 `1`，所以会进入标签 `1` 的代码段。**跳转到标签 `1` (`je 1f`)**，更新当前任务标志变量 `current` 为 `0`，执行长跳转到任务 0 的 TSS 段（`TSS0_SEL`），触发硬件任务切换，进行了 `TSS0` 中数据的加载。

#### 2.3.4.2 TSS 和寄存器值的变化

**主要关注执行长跳转指令之前的 `tss 1 ` 中对应的各个寄存器的值**，首先根据 `%tr` 寄存器确认当前为 `TSS1`，更多的可以看见当前的 `%eip` 为 `0x15c`，当前的 `%cs` 为 `0x8`，长跳转指令此时会去执行 `task0`，这意味着在重新切换到当前任务的时候会接着保存的 `%eip` 和 `%cs` 指出的下一行的代码继续执行。
![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241123034827.png)
当**执行了长跳转指令后，当前的 tss 为 `tss0`，关注当前的各个寄存器的值**，`%tr` 寄存器为 `0xbf8`，这确保了当前的 `tss` 为 `tss0`，此时查看寄存器的值，`%eip` 与上述图片中已经不同，并且 `%es` 指向的也不是原来指令中的代码段。
![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241123035158.png)
我们继续切换到 `task1` 来佐证保存在 `tss1` 中的 `%es` 和 `%eip` 的寄存器将会再次得到使用，当切换回的时候，代码会在当前部分继续执行，这证明了从 `task1` 切换到 `task0` 的时候会保存在 `tss1` 当前 `task1` 执行到的步骤，在返回 `task1` 的时候会继续执行。
![image.png](https://raw.githubusercontent.com/MarchPhantasia/pic/main/hexoblog/20241123035902.png)

**整个流程可以总结为：** 在中断处理函数中，判断当前执行的任务为任务 1，执行长跳转到 `TSS0`，**任务切换前硬件将 task1 的上下文保存到 TSS1 中，根据 TSS0 保存的数据恢复 task0 的状态**（`regs` 等），比如 `cs:eip` 保存了上次任务切换长跳转指令的下一条语句（此处为 `0x150`），任务切换后，`task0` 在 `0x150` 处继续执行。

### 2.3.5 请详细总结任务切换的过程

任务切换是操作系统内核中的一个核心机制，它允许操作系统在多个任务之间进行高效的切换，从而实现多任务并发执行。在 Linux 0.00 内核中，任务切换主要通过时钟中断和硬件任务切换机制来实现。以下是任务切换过程的详细总结：

#### 1. 时钟中断的触发

- **时钟中断的产生**：时钟中断是由硬件定时器（如 8253/8254 定时器）周期性触发的。在 Linux 0.00 内核中，时钟中断的频率通常设置为每秒 100 次，即每 10ms 触发一次。
- **中断处理程序的执行**：当时钟中断发生时，CPU 会暂停当前任务的执行，并跳转到预定义的时钟中断处理程序 `timer_interrupt`。

#### 2. 中断处理程序的执行

- **保存当前任务的上下文**：在进入 `timer_interrupt` 之前，CPU 会自动保存当前任务的上下文（包括 `EFLAGS`、`CS`、`EIP`、`ESP` 和 `SS`）到当前任务的内核栈中。
- **切换到内核栈**：由于时钟中断处理程序是内核级的，CPU 会从当前任务的 TSS 中加载内核栈的指针，并切换到内核栈。

#### 3. 中断处理程序的逻辑

- **保存寄存器**：在 `timer_interrupt` 中，首先保存通用寄存器 `%ds` 和 `%eax` 的值到栈中，以保护中断处理程序中的临时计算不会破坏原寄存器值。
- **发送 EOI 命令**：通过向 8259 中断控制器发送 EOI 命令（`0x20`），通知中断处理结束，可以响应新的中断。
- **判断当前任务**：通过比较 `current` 变量与 `1`，判断当前执行的任务是任务 0 还是任务 1。

#### 4. 任务切换的执行

- **更新 `current` 变量**：根据当前任务的标识，更新 `current` 变量为下一个任务的标识（从任务 0 切换到任务 1，或从任务 1 切换到任务 0）。
- **长跳转指令**：执行长跳转指令 `ljmp`，跳转到下一个任务的 TSS 段（`TSS0_SEL` 或 `TSS1_SEL`）。长跳转指令会触发硬件任务切换，加载下一个任务的 TSS 中的上下文（包括段寄存器、寄存器、堆栈指针等），并切换到下一个任务的内核栈。
- **恢复寄存器**：在任务切换完成后，恢复之前保存的 `%ds` 和 `%eax` 寄存器的值。

#### 5. 中断返回

- **中断返回指令 `iret`**：执行 `iret` 指令，从内核栈中弹出之前保存的 `EFLAGS`、`CS`、`EIP`、`ESP` 和 `SS` 的值，恢复到用户态，继续执行下一个任务。

#### 6. TSS 的变化

- **TSS 的保存与恢复**：在任务切换过程中，硬件会自动将当前任务的上下文保存到对应的 TSS 中，并从下一个任务的 TSS 中恢复上下文。TSS 中保存了任务的所有寄存器状态、堆栈指针等信息，确保任务切换后能够正确恢复执行。

#### 7. 寄存器值的变化

- **寄存器的保存与恢复**：在任务切换过程中，所有通用寄存器、段寄存器、标志寄存器等都会被保存到当前任务的 TSS 中，并在切换到下一个任务时从 TSS 中恢复。具体来说，`EIP`、`CS`、`EFLAGS`、`ESP`、`SS` 等寄存器的值会在任务切换时发生变化，以确保任务能够正确恢复执行。

#### 8. 任务切换的流程总结

1. **时钟中断触发**，CPU 暂停当前任务的执行，跳转到 `timer_interrupt`。
2. **保存当前任务的上下文**，切换到内核栈。
3. **执行中断处理程序**，保存寄存器、发送 EOI 命令、判断当前任务。
4. **执行任务切换**，更新 `current` 变量，执行长跳转指令，加载下一个任务的 TSS。
5. **恢复寄存器**，执行 `iret` 指令，恢复到用户态，继续执行下一个任务。
6. **TSS 的保存与恢复**，确保任务切换后能够正确恢复执行。
7. **寄存器值的变化**，确保任务切换后能够正确恢复执行。

通过上述步骤，Linux 0.00 内核实现了高效的任务切换，确保多个任务能够在单个 CPU 上并发执行。
